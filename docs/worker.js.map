{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/classes/ComputeShapeOutside.js","webpack:///./src/js/classes/Line.js","webpack:///./src/js/classes/PointList.js","webpack:///./src/js/classes/Polygon.js","webpack:///./src/js/worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","ComputeShapeOutside","imageData","options","_classCallCheck","this","width","height","data","useAlpha","threshold","padding","wPadding","wWidth","wHeight","rawMask","_computeRawMask","paddedMask","_computePaddedMask","rawContour","_computeRawContour","polygon","_computePolygon","pixelData","ImageData","rawMaskData","_getImageDataFromGrid","paddedMaskData","shapeOutsidePolygon","_getCSS","grid","Array","x","Uint8Array","Uint8ClampedArray","y","gb","_options","start","_getNewGrid","imgX","length","mask","edges","_PointList2","default","maxX","maxY","isInner","g","foundEdgesGrid","push","notInGrid","isNewEdge","_loop","candidateEdges","forEach","pushIf","filter","_Polygon2","_polygon$getFirst","getFirst","_polygon$getFirst2","_slicedToArray","firstX","firstY","_polygon$getLast","getLast","_polygon$getLast2","lastX","lastY","contour","epsilon","simplify","position","_clipAndGetCSS","clipLeft","clipRight","clipTop","clipBottom","clipped","curWidth","curHeight","clip","translate","result","xScale","yScale","_clipped$getAt","getAt","_clipped$getAt2","xp","toFixed","yp","join","Line","x1","y1","x2","y2","dx","dy","squareLength","dot","numerator","other","xNumerator","yNumerator","denominator","Math","round","PointList","expectedLength","Uint16Array","newStorageLength","newX","newY","set","addlLength","_extendStorage","testFunc","index","newLength","slice","callback","begin","end","constructor","filterFunc","filtered","Polygon","isInFunc","line","_Line2","maxI","lastIsIn","isIn","intersect","intersectWith","epsilon2","_douglasPeucker","curX","curY","maxDistance2","maxDistanceIndex","distance2","squareDistanceFrom","concat","_ComputeShapeOutside","self","addEventListener","e","_e$data","_ComputeShapeOutside2","run","postMessage"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAIA3B,IAAA4B,EAAA,gzBChEA5B,EAAA,sCACAA,EAAA,uFAEqB6B,aACnB,SAAAA,EAAYC,EAAWC,gGAASC,CAAAC,KAAAJ,GAC9BI,KAAKC,MAAQJ,EAAUI,MACvBD,KAAKE,OAASL,EAAUK,OACxBF,KAAKH,UAAYA,EAAUM,MAC3BL,EAAUA,OACFM,SAAWN,EAAQM,WAAY,EACvCN,EAAQO,UAAYP,EAAQO,WAAa,IACzCP,EAAQQ,QAAUR,EAAQQ,SAAW,GACrCN,KAAKF,QAAUA,EAEfE,KAAKO,SAAWT,EAAQQ,QAAU,EAClCN,KAAKQ,OAASR,KAAKC,MAAS,EAAID,KAAKO,SACrCP,KAAKS,QAAUT,KAAKE,OAAU,EAAIF,KAAKO,iDAIvC,IAAMG,EAAUV,KAAKW,kBACfC,EAAaZ,KAAKa,mBAAmBH,GACrCI,EAAad,KAAKe,mBAAmBH,GACrCI,EAAUhB,KAAKiB,gBAAgBH,GACrC,OACEhB,QAASE,KAAKF,QACdG,MAAOD,KAAKC,MACZC,OAAQF,KAAKE,OACbgB,UAAW,IAAIC,UAAUnB,KAAKH,UAAWG,KAAKC,MAAOD,KAAKE,QAC1DkB,YAAapB,KAAKqB,sBAAsBX,GACxCY,eAAgBtB,KAAKqB,sBAAsBT,GAC3CE,aACAE,UACAO,oBAAqBvB,KAAKwB,QAAQR,0CAMpC,IADA,IAAMS,EAAO,IAAIC,MAAM1B,KAAKQ,QACnBmB,EAAI,EAAGA,EAAI3B,KAAKQ,OAAQmB,IAC/BF,EAAKE,GAAK,IAAIC,WAAW5B,KAAKS,SAEhC,OAAOgB,gDAGaA,GAGpB,IAFA,IAAM5B,EAAY,IAAIgC,kBAAkB7B,KAAKQ,OAASR,KAAKS,QAAU,GACjEtC,EAAI,EACC2D,EAAI,EAAGA,EAAI9B,KAAKS,QAASqB,IAChC,IAAK,IAAIH,EAAI,EAAGA,EAAI3B,KAAKQ,OAAQmB,IAAK,CACpC,IAAMzC,EAAmB,IAAfuC,EAAKE,GAAGG,GAAW,EAAI,IAC3BC,EAAKN,EAAKE,GAAGG,GAAK,EAAI,EAAI5C,EAChCW,EAAU1B,KAAOe,EACjBW,EAAU1B,KAAO4D,EACjBlC,EAAU1B,KAAO4D,EACjBlC,EAAU1B,KAAO,IAGrB,OAAO,IAAIgD,UAAUtB,EAAWG,KAAKQ,OAAQR,KAAKS,mDAalD,IAVgB,IAAAuB,EAEgBhC,KAAKF,QAA7BM,EAFQ4B,EAER5B,SAAUC,EAFF2B,EAEE3B,UACZa,EAAYlB,KAAKH,UACjBoC,EAAQjC,KAAKO,SACbkB,EAAOzB,KAAKkC,cAEdC,EAAO,EACPR,EAAIM,EACJH,EAAIG,EACCvC,EAAI,EAAGA,EAAIwB,EAAUkB,OAAQ1C,GAAK,EAAG,CAC5C,GAAIU,EACFqB,EAAKE,GAAGG,GAAKZ,EAAUxB,EAAI,GAAKW,EAAY,EAAI,MAC3C,CAEL,IAAMjC,EAAK,MAAS8C,EAAUxB,GACnB,MAASwB,EAAUxB,EAAI,GACvB,MAASwB,EAAUxB,EAAI,GAClC+B,EAAKE,GAAGG,GAAK1D,EAAIiC,EAAY,EAAI,EAEnCsB,MACAQ,IACanC,KAAKC,QAChBkC,EAAO,EACPR,EAAIM,EACJH,KAGJ,OAAOL,6CAGUY,GAWjB,IAXuB,IACf/B,EAAYN,KAAKF,QAAjBQ,QACFmB,EAAOzB,KAAKkC,cAEdI,EAAQ,IAAAC,EAAAC,QACNC,EAAOzC,KAAKQ,OAAS,EACrBkC,EAAO1C,KAAKS,QAAU,EAEtBkC,EAAU,SAACC,EAAGjB,EAAGG,GAAP,OAAac,EAAEjB,EAAI,GAAGG,IAAMc,EAAEjB,EAAI,GAAGG,IAAMc,EAAEjB,GAAGG,EAAI,IAAMc,EAAEjB,GAAGG,EAAI,IAE7Ee,EAAiB7C,KAAKkC,cACnBP,EAAI,EAAGA,GAAKc,EAAMd,IACzB,IAAK,IAAIG,EAAI,EAAGA,GAAKY,EAAMZ,IACpBO,EAAKV,GAAGG,IAGXL,EAAKE,GAAGG,GAAK,EACRa,EAAQN,EAAMV,EAAGG,KACpBQ,EAAMQ,KAAKnB,EAAGG,GACde,EAAelB,GAAGG,GAAK,IALzBL,EAAKE,GAAGG,GAAK,EAsBnB,IAVA,IAAMiB,EAAY,SAACpB,EAAGG,GAAJ,OAAWa,EAAQlB,EAAME,EAAGG,IACxCkB,EAAY,SAACrB,EAAGG,GACpB,OAAKe,EAAelB,GAAGG,KACrBe,EAAelB,GAAGG,GAAK,GAChB,IA9BYmB,EAAA,SAoCd9E,GACP,IAAM+E,EAAiB,IAAAX,EAAAC,QAEvBF,EAAMa,QAAQ,SAACxB,EAAGG,GAChBoB,EAAeE,OAAOzB,EAAI,EAAGG,EAAGkB,GAChCE,EAAeE,OAAOzB,EAAI,EAAGG,EAAGkB,GAChCE,EAAeE,OAAOzB,EAAGG,EAAI,EAAGkB,GAChCE,EAAeE,OAAOzB,EAAGG,EAAI,EAAGkB,KAGlCV,EAAQY,EAAeG,OAAON,IAVvB5E,EAAI,EAAGA,EAAImC,EAASnC,IAAK8E,IAiBlC,OAHAX,EAAMa,QAAQ,SAACxB,EAAGG,GAChBL,EAAKE,GAAGG,GAAK,IAERL,6CAGUY,GAMjB,IALA,IAAMrB,EAAU,IAAAsC,EAAAd,QACVC,EAAOzC,KAAKQ,OAAS,EACrBkC,EAAO1C,KAAKS,QAAU,EAGnBqB,EAAI,EAAGA,GAAKY,EAAMZ,IAAK,CAE9B,IADA,IAAIH,EAAIc,EACDd,GAAK,GAAoB,IAAfU,EAAKV,GAAGG,IACvBH,IAEEA,GAAK,GACPX,EAAQ8B,KAAKnB,EAAGG,GAMpB,IAlBuB,IAAAyB,EAeEvC,EAAQwC,WAfVC,EAAAC,EAAAH,EAAA,GAehBI,EAfgBF,EAAA,GAeRG,EAfQH,EAAA,GAAAI,EAgBA7C,EAAQ8C,UAhBRC,EAAAL,EAAAG,EAAA,GAgBhBG,EAhBgBD,EAAA,GAgBTE,EAhBSF,EAAA,GAkBdjC,EAAImC,EAAOnC,GAAK,EAAGA,IAAK,CAE/B,IADA,IAAIH,EAAI,EACDA,GAAKc,GAAuB,IAAfJ,EAAKV,GAAGG,IAC1BH,IAEEA,GAAKc,IACFX,IAAMmC,GAAStC,IAAMqC,GAAWlC,IAAM8B,GAAUjC,IAAMgC,GAGzD3C,EAAQ8B,KAAKnB,EAAGG,IAItB,OAAOd,0CAGOkD,GACd,IAAMC,EAAUnE,KAAKF,QAAQQ,QAAU,EACvC,OAAO4D,EAAQE,SAASD,mCAGlBnD,GACN,OAAQhB,KAAKF,QAAQuE,UACnB,IAAK,OACH,OAAOrE,KAAKsE,eAAetD,GAAS,GAAM,GAAO,GAAM,GACzD,IAAK,QACH,OAAOhB,KAAKsE,eAAetD,GAAS,GAAO,GAAM,GAAM,GACzD,QACE,OAAOhB,KAAKsE,eAAetD,GAAS,GAAO,GAAO,GAAM,2CAI/CA,EAASuD,EAAUC,EAAWC,EAASC,GAAY,IACxDnE,EAAaP,KAAbO,SAGJoE,EAAU3D,EACV4D,EAAW5E,KAAKQ,OAChBqE,EAAY7E,KAAKS,QAOrB,GANI8D,IACFI,EAAUA,EACPG,KAAKvE,EAAU,EAAGA,EAAUsE,EAAW,SAAAlD,GAAA,OAAMA,GAAKpB,IAClDwE,WAAWxE,EAAU,GACxBqE,GAAYrE,GAEViE,EAAW,CACb,IAAM/B,EAAOmC,EAAW,EAAIrE,EAC5BoE,EAAUA,EACPG,KAAKrC,EAAM,EAAGA,EAAMoC,EAAW,SAAAlD,GAAA,OAAMA,GAAKc,IAC7CmC,GAAYrE,EAQd,GANIkE,IACFE,EAAUA,EACPG,KAAK,EAAGvE,EAAUqE,EAAUrE,EAAU,SAACoB,EAAGG,GAAJ,OAAWA,GAAKvB,IACtDwE,UAAU,GAAIxE,GACjBsE,GAAatE,GAEXmE,EAAY,CACd,IAAMhC,EAAOmC,EAAY,EAAItE,EAC7BoE,EAAUA,EACPG,KAAK,EAAGpC,EAAMkC,EAAUlC,EAAM,SAACf,EAAGG,GAAJ,OAAWA,GAAKY,IACjDmC,GAAatE,EAOf,IAHA,IAAMyE,KACAC,EAAS,KAAOL,EAAW,GAC3BM,EAAS,KAAOL,EAAY,GACzB1G,EAAI,EAAGA,EAAIwG,EAAQvC,OAAQjE,IAAK,KAAAgH,EACxBR,EAAQS,MAAMjH,GADUkH,EAAA3B,EAAAyB,EAAA,GAChCxD,EADgC0D,EAAA,GAC7BvD,EAD6BuD,EAAA,GAEjCC,GAAS3D,EAAIsD,GAAQM,QAAQ,GAA7B,IACAC,GAAS1D,EAAIoD,GAAQK,QAAQ,GAA7B,IACNP,EAAOlC,KAAQwC,EAAf,IAAqBE,GAEvB,OAAOR,EAAOS,KAAK,yBA7OF7F,yWCNA8F,aACnB,SAAAA,EAAYC,EAAIC,EAAIC,EAAIC,gGAAI/F,CAAAC,KAAA0F,GAC1B1F,KAAK2F,GAAKA,EACV3F,KAAK4F,GAAKA,EACV5F,KAAK6F,GAAKA,EACV7F,KAAK8F,GAAKA,EACV9F,KAAK+F,GAAK/F,KAAK6F,GAAK7F,KAAK2F,GACzB3F,KAAKgG,GAAKhG,KAAK8F,GAAK9F,KAAK4F,GACzB5F,KAAKiG,aAAgBjG,KAAK+F,GAAK/F,KAAK+F,GAAO/F,KAAKgG,GAAKhG,KAAKgG,GAG1DhG,KAAKkG,IAAOlG,KAAK6F,GAAK7F,KAAK4F,GAAO5F,KAAK2F,GAAK3F,KAAK8F,wDAGhCnE,EAAGG,GAEpB,IAAMqE,EAAcnG,KAAKgG,GAAKrE,EAAM3B,KAAK+F,GAAKjE,EAAM9B,KAAKkG,IACzD,OAAQC,EAAYA,EAAanG,KAAKiG,mDAG1BG,GAEZ,IAAMC,EAAcrG,KAAKkG,IAAME,EAAML,GAAOK,EAAMF,IAAMlG,KAAK+F,GACvDO,EAActG,KAAKkG,IAAME,EAAMJ,GAAOI,EAAMF,IAAMlG,KAAKgG,GACvDO,EAAevG,KAAK+F,GAAKK,EAAMJ,GAAOI,EAAML,GAAK/F,KAAKgG,GAG5D,OAFWQ,KAAKC,MAAMJ,EAAaE,GACxBC,KAAKC,MAAMH,EAAaC,uBA1BlBb,8WCAAgB,aACnB,SAAAA,EAAYC,gGAAgB5G,CAAAC,KAAA0G,GAC1B1G,KAAK2B,EAAI,IAAIiF,YAAYD,GAAkB,IAC3C3G,KAAK8B,EAAI,IAAI8E,YAAYD,GAAkB,IAC3C3G,KAAKoC,OAAS,mDAGDyE,GACb,IAAMC,EAAO,IAAIF,YAAYC,GACvBE,EAAO,IAAIH,YAAYC,GAC7BC,EAAKE,IAAIhH,KAAK2B,EAAG,GACjBoF,EAAKC,IAAIhH,KAAK8B,EAAG,GACjB9B,KAAK2B,EAAImF,EACT9G,KAAK8B,EAAIiF,+BAGNpF,EAAGG,GACN,GAAI9B,KAAKoC,SAAWpC,KAAK2B,EAAES,OAAQ,CACjC,IAAM6E,EAAajH,KAAKoC,OAAS,MAAQpC,KAAKoC,OAAS,MACvDpC,KAAKkH,eAAelH,KAAKoC,OAAS6E,GAEpCjH,KAAK2B,EAAE3B,KAAKoC,QAAUT,EACtB3B,KAAK8B,EAAE9B,KAAKoC,QAAUN,EACtB9B,KAAKoC,wCAGAT,EAAGG,EAAGqF,GACPA,EAASxF,EAAGG,IACd9B,KAAK8C,KAAKnB,EAAGG,iCAIXsF,GACJ,OAAQpH,KAAK2B,EAAEyF,GAAQpH,KAAK8B,EAAEsF,uCAI9B,OAAOpH,KAAKoF,MAAM,qCAIlB,OAAOpF,KAAKoF,MAAMpF,KAAKoC,OAAS,kCAG3BgE,GACL,IAAMiB,EAAYrH,KAAKoC,OAASgE,EAAMhE,OAOtC,OANIpC,KAAK2B,EAAES,QAAUiF,GACnBrH,KAAKkH,eAAeG,GAEtBrH,KAAK2B,EAAEqF,IAAIZ,EAAMzE,EAAE2F,MAAM,EAAGlB,EAAMhE,QAASpC,KAAKoC,QAChDpC,KAAK8B,EAAEkF,IAAIZ,EAAMtE,EAAEwF,MAAM,EAAGlB,EAAMhE,QAASpC,KAAKoC,QAChDpC,KAAKoC,OAASiF,EACPrH,uCAGC+F,EAAIC,GACZ,IAAK,IAAI7H,EAAI,EAAGA,EAAI6B,KAAKoC,OAAQjE,IAC/B6B,KAAK2B,EAAExD,IAAM4H,EACb/F,KAAK8B,EAAE3D,IAAM6H,EAEf,OAAOhG,qCAGDuH,EAAUC,EAAOC,GACvBD,EAAQA,GAAS,EACjBC,EAAMA,GAAOzH,KAAKoC,OAClB,IAAK,IAAIjE,EAAIqJ,EAAOrJ,EAAIsJ,EAAKtJ,IAAK,CAEhC,GADmBoJ,EAASvH,KAAK2B,EAAExD,GAAI6B,KAAK8B,EAAE3D,GAAIA,GAClC,sCAIdqJ,EAAOC,GACX,IAAMrF,EAASqF,EAAMD,EACfF,EAAQ,IAAItH,KAAK0H,YAAYtF,GAInC,OAHAkF,EAAM3F,EAAEqF,IAAIhH,KAAK2B,EAAE2F,MAAME,EAAOC,IAChCH,EAAMxF,EAAEkF,IAAIhH,KAAK8B,EAAEwF,MAAME,EAAOC,IAChCH,EAAMlF,OAASA,EACRkF,iCAGFK,GACL,IAAMC,EAAW,IAAI5H,KAAK0H,YAI1B,OAHA1H,KAAKmD,QAAQ,SAACxB,EAAGG,GACf8F,EAASxE,OAAOzB,EAAGG,EAAG6F,KAEjBC,qBAtFUlB,4WCArB3I,EAAA,sCACAA,EAAA,oFAEqB8J,2tBACdlC,EAAIC,EAAIC,EAAIC,EAAIgC,GAQnB,IAPA,IAAMC,EAAO,IAAAC,EAAAxF,QAASmD,EAAIC,EAAIC,EAAIC,GAE5Bd,EAAS,IAAI6C,EACbI,EAAOjI,KAAKoC,OAAS,EACvB4B,EAAQhE,KAAK2B,EAAEsG,GACfhE,EAAQjE,KAAK8B,EAAEmG,GACfC,EAAWJ,EAAS9D,EAAOC,GACtB9F,EAAI,EAAGA,GAAK8J,EAAM9J,IAAK,CAC9B,IAAMwD,EAAI3B,KAAK2B,EAAExD,GACX2D,EAAI9B,KAAK8B,EAAE3D,GACXgK,EAAOL,EAASnG,EAAGG,GACzB,GAAIqG,EAAOD,EAAU,CACnB,IAAME,EAAYL,EAAKM,cAAc,IAAAL,EAAAxF,QAASwB,EAAOC,EAAOtC,EAAGG,IAC/DkD,EAAOlC,KAAKsF,EAAU,GAAIA,EAAU,IAElCD,GAAMnD,EAAOlC,KAAKnB,EAAGG,GACzBkC,EAAQrC,EACRsC,EAAQnC,EACRoG,EAAWC,EAEb,OAAOnD,mCAGAb,GACP,IAAMmE,EAAWnE,EAAUA,EACrBnD,EAAUhB,KAAKuI,gBAAgBD,GAG/BtD,EAAS,IAAI6C,EACbI,EAAOjH,EAAQoB,OAAS,EAC1BoG,EAAOxH,EAAQW,EAAEsG,GACjBQ,EAAOzH,EAAQc,EAAEmG,GAUrB,OATAjD,EAAOlC,KAAK0F,EAAMC,GAClBzH,EAAQmC,QAAQ,SAACxB,EAAGG,GACL,IAAAkG,EAAAxF,QAASgG,EAAMC,EAAM9G,EAAGG,GAC5BmE,cAAgBqC,IACvBE,EAAO7G,EACP8G,EAAO3G,EACPkD,EAAOlC,KAAK0F,EAAMC,MAGfzD,0CAGOsD,GAEd,GAAItI,KAAKoC,QAAU,EAAG,OAAOpC,KAO7B,IAJA,IAAMiI,EAAOjI,KAAKoC,OAAS,EACvBsG,EAAe,EACfC,EAAmB,EACjBZ,EAAO,IAAAC,EAAAxF,QAASxC,KAAK2B,EAAE,GAAI3B,KAAK8B,EAAE,GAAI9B,KAAK2B,EAAEsG,GAAOjI,KAAK8B,EAAEmG,IACxD9J,EAAI,EAAGA,EAAI8J,EAAM9J,IAAK,CAC7B,IAAMyK,EAAYb,EAAKc,mBAAmB7I,KAAK2B,EAAExD,GAAI6B,KAAK8B,EAAE3D,IACxDyK,EAAYF,IACdA,EAAeE,EACfD,EAAmBxK,GAKvB,GAAIuK,GAAgBJ,EAAU,CAC5B,IAAMtD,EAAS,IAAI6C,EAAQ,GAG3B,OAFA7C,EAAOlC,KAAK9C,KAAK2B,EAAE,GAAI3B,KAAK8B,EAAE,IAC9BkD,EAAOlC,KAAK9C,KAAK2B,EAAEsG,GAAOjI,KAAK8B,EAAEmG,IAC1BjD,EAGT,IAAMA,EAAS,IAAI6C,EAGnB,OAFA7C,EAAO8D,OAAO9I,KAAKsH,MAAM,EAAGqB,GAAkBJ,gBAAgBD,IAC9DtD,EAAO8D,OAAO9I,KAAKsH,MAAMqB,EAAkB3I,KAAKoC,QAAQmG,gBAAgBD,IACjEtD,qBA1EU6C,qDCFrB,MAAAkB,EAAAhL,EAAA,+EAEAiL,KAAKC,iBAAiB,UAAW,SAACC,GAAM,IAAAC,EACPD,EAAE/I,KAAzBN,EAD8BsJ,EAC9BtJ,UAAWC,EADmBqJ,EACnBrJ,QACbkF,EAAU,IAAAoE,EAAA5G,QAAwB3C,EAAWC,GAAUuJ,MAC7DL,KAAKM,YAAYtE","file":"worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/worker.js\");\n","// TODO: add debugging flag with stats\n// TODO: grid class\n\nimport PointList from './PointList';\nimport Polygon from './Polygon';\n\nexport default class ComputeShapeOutside {\n  constructor(imageData, options) {\n    this.width = imageData.width;\n    this.height = imageData.height;\n    this.imageData = imageData.data;\n    options = options || {};\n    options.useAlpha = options.useAlpha || false;\n    options.threshold = options.threshold || 250;\n    options.padding = options.padding || 20;\n    this.options = options;\n\n    this.wPadding = options.padding + 1;\n    this.wWidth = this.width + (2 * this.wPadding);\n    this.wHeight = this.height + (2 * this.wPadding);\n  }\n\n  run() {\n    const rawMask = this._computeRawMask();\n    const paddedMask = this._computePaddedMask(rawMask);\n    const rawContour = this._computeRawContour(paddedMask);\n    const polygon = this._computePolygon(rawContour);\n    return {\n      options: this.options,\n      width: this.width,\n      height: this.height,\n      pixelData: new ImageData(this.imageData, this.width, this.height),\n      rawMaskData: this._getImageDataFromGrid(rawMask),\n      paddedMaskData: this._getImageDataFromGrid(paddedMask),\n      rawContour,\n      polygon,\n      shapeOutsidePolygon: this._getCSS(polygon),\n    };\n  }\n\n  _getNewGrid() {\n    const grid = new Array(this.wWidth);\n    for (let x = 0; x < this.wWidth; x++) {\n      grid[x] = new Uint8Array(this.wHeight);\n    }\n    return grid;\n  }\n\n  _getImageDataFromGrid(grid) {\n    const imageData = new Uint8ClampedArray(this.wWidth * this.wHeight * 4);\n    let i = 0;\n    for (let y = 0; y < this.wHeight; y++) {\n      for (let x = 0; x < this.wWidth; x++) {\n        const r = grid[x][y] === 1 ? 0 : 255;\n        const gb = grid[x][y] > 1 ? 0 : r;\n        imageData[i++] = r;\n        imageData[i++] = gb;\n        imageData[i++] = gb;\n        imageData[i++] = 255;\n      }\n    }\n    return new ImageData(imageData, this.wWidth, this.wHeight);\n  }\n\n  _computeRawMask() {\n    // make a 2D grid with values, using the threshold\n    const { useAlpha, threshold } = this.options;\n    const pixelData = this.imageData;\n    const start = this.wPadding;\n    const grid = this._getNewGrid();\n\n    let imgX = 0;\n    let x = start;\n    let y = start;\n    for (let p = 0; p < pixelData.length; p += 4) {\n      if (useAlpha) {\n        grid[x][y] = pixelData[p + 3] < threshold ? 0 : 1;\n      } else {\n        // compute luminance\n        const l = (0.2126 * pixelData[p]) +\n                  (0.7152 * pixelData[p + 1]) +\n                  (0.0722 * pixelData[p + 2]);\n        grid[x][y] = l > threshold ? 0 : 1;\n      }\n      x++;\n      imgX++;\n      if (imgX === this.width) {\n        imgX = 0;\n        x = start;\n        y++;\n      }\n    }\n    return grid;\n  }\n\n  _computePaddedMask(mask) {\n    const { padding } = this.options;\n    const grid = this._getNewGrid();\n    // flag edge points as 2 and maintain a list\n    let edges = new PointList();\n    const maxX = this.wWidth - 1;\n    const maxY = this.wHeight - 1;\n\n    const isInner = (g, x, y) => g[x - 1][y] && g[x + 1][y] && g[x][y - 1] && g[x][y + 1];\n    // copy mask in grid and find initial edges\n    const foundEdgesGrid = this._getNewGrid();\n    for (let x = 0; x <= maxX; x++) {\n      for (let y = 0; y <= maxY; y++) {\n        if (!mask[x][y]) {\n          grid[x][y] = 0;\n        } else {\n          grid[x][y] = 1;\n          if (!isInner(mask, x, y)) {\n            edges.push(x, y);\n            foundEdgesGrid[x][y] = 1;\n          }\n        }\n      }\n    }\n\n    // TODO: move to grid class\n    const notInGrid = (x, y) => !isInner(grid, x, y);\n    const isNewEdge = (x, y) => {\n      if (!foundEdgesGrid[x][y]) {\n        foundEdgesGrid[x][y] = 1;\n        return true;\n      }\n      return false;\n    };\n\n    // expand the edges, 1 pixel at a time\n    for (let i = 0; i < padding; i++) {\n      const candidateEdges = new PointList();\n\n      edges.forEach((x, y) => {\n        candidateEdges.pushIf(x - 1, y, isNewEdge);\n        candidateEdges.pushIf(x + 1, y, isNewEdge);\n        candidateEdges.pushIf(x, y - 1, isNewEdge);\n        candidateEdges.pushIf(x, y + 1, isNewEdge);\n      });\n\n      edges = candidateEdges.filter(notInGrid);\n    }\n\n    // store edges on the grid for next step\n    edges.forEach((x, y) => {\n      grid[x][y] = 2;\n    });\n    return grid;\n  }\n\n  _computeRawContour(mask) {\n    const polygon = new Polygon();\n    const maxX = this.wWidth - 1;\n    const maxY = this.wHeight - 1;\n\n    // starting from top, find rightmost edges\n    for (let y = 0; y <= maxY; y++) {\n      let x = maxX;\n      while (x >= 0 && mask[x][y] !== 2) {\n        x--;\n      }\n      if (x >= 0) {\n        polygon.push(x, y);\n      }\n    }\n    const [firstX, firstY] = polygon.getFirst();\n    const [lastX, lastY] = polygon.getLast();\n    // starting from bottom, find leftmost edges\n    for (let y = lastY; y >= 0; y--) {\n      let x = 0;\n      while (x <= maxX && mask[x][y] !== 2) {\n        x++;\n      }\n      if (x <= maxX) {\n        if ((y === lastY && x === lastX) || (y === firstY && x === firstX)) {\n          // no duplicate\n        } else {\n          polygon.push(x, y);\n        }\n      }\n    }\n    return polygon;\n  }\n\n  _computePolygon(contour) {\n    const epsilon = this.options.padding / 5; // TODO: cap and/or param\n    return contour.simplify(epsilon);\n  }\n\n  _getCSS(polygon) {\n    switch (this.options.position) {\n      case 'left':\n        return this._clipAndGetCSS(polygon, true, false, true, false);\n      case 'right':\n        return this._clipAndGetCSS(polygon, false, true, true, false);\n      default:\n        return this._clipAndGetCSS(polygon, false, false, true, true);\n    }\n  }\n\n  _clipAndGetCSS(polygon, clipLeft, clipRight, clipTop, clipBottom) {\n    const { wPadding } = this;\n\n    // a bit like https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\n    let clipped = polygon;\n    let curWidth = this.wWidth;\n    let curHeight = this.wHeight;\n    if (clipLeft) {\n      clipped = clipped\n        .clip(wPadding, 0, wPadding, curHeight, x => (x >= wPadding))\n        .translate(-wPadding, 0);\n      curWidth -= wPadding;\n    }\n    if (clipRight) {\n      const maxX = curWidth - 1 - wPadding;\n      clipped = clipped\n        .clip(maxX, 0, maxX, curHeight, x => (x <= maxX));\n      curWidth -= wPadding;\n    }\n    if (clipTop) {\n      clipped = clipped\n        .clip(0, wPadding, curWidth, wPadding, (x, y) => (y >= wPadding))\n        .translate(0, -wPadding);\n      curHeight -= wPadding;\n    }\n    if (clipBottom) {\n      const maxY = curHeight - 1 - wPadding;\n      clipped = clipped\n        .clip(0, maxY, curWidth, maxY, (x, y) => (y <= maxY));\n      curHeight -= wPadding;\n    }\n\n    // scale to %\n    const result = [];\n    const xScale = 100 / (curWidth - 1);\n    const yScale = 100 / (curHeight - 1);\n    for (let i = 0; i < clipped.length; i++) {\n      const [x, y] = clipped.getAt(i);\n      const xp = `${(x * xScale).toFixed(0)}%`;\n      const yp = `${(y * yScale).toFixed(0)}%`;\n      result.push(`${xp} ${yp}`);\n    }\n    return result.join(', ');\n  }\n}\n","export default class Line {\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.dx = this.x2 - this.x1;\n    this.dy = this.y2 - this.y1;\n    this.squareLength = (this.dx * this.dx) + (this.dy * this.dy);\n    // TODO: find how this thing is actually called\n    // since it's used in both the distance function and the intersection function\n    this.dot = (this.x2 * this.y1) - (this.x1 * this.y2);\n  }\n\n  squareDistanceFrom(x, y) {\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const numerator = ((this.dy * x) - (this.dx * y)) + this.dot;\n    return (numerator * numerator) / this.squareLength;\n  }\n\n  intersectWith(other) {\n    // https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n    const xNumerator = (this.dot * other.dx) - (other.dot * this.dx);\n    const yNumerator = (this.dot * other.dy) - (other.dot * this.dy);\n    const denominator = (this.dx * other.dy) - (other.dx * this.dy);\n    const ix = Math.round(xNumerator / denominator);\n    const iy = Math.round(yNumerator / denominator);\n    return [ix, iy];\n  }\n}\n","export default class PointList {\n  constructor(expectedLength) {\n    this.x = new Uint16Array(expectedLength || 64);\n    this.y = new Uint16Array(expectedLength || 64);\n    this.length = 0;\n  }\n\n  _extendStorage(newStorageLength) {\n    const newX = new Uint16Array(newStorageLength);\n    const newY = new Uint16Array(newStorageLength);\n    newX.set(this.x, 0);\n    newY.set(this.y, 0);\n    this.x = newX;\n    this.y = newY;\n  }\n\n  push(x, y) {\n    if (this.length === this.x.length) {\n      const addlLength = this.length < 65536 ? this.length : 65536;\n      this._extendStorage(this.length + addlLength);\n    }\n    this.x[this.length] = x;\n    this.y[this.length] = y;\n    this.length++;\n  }\n\n  pushIf(x, y, testFunc) {\n    if (testFunc(x, y)) {\n      this.push(x, y);\n    }\n  }\n\n  getAt(index) {\n    return [this.x[index], this.y[index]];\n  }\n\n  getFirst() {\n    return this.getAt(0);\n  }\n\n  getLast() {\n    return this.getAt(this.length - 1);\n  }\n\n  concat(other) {\n    const newLength = this.length + other.length;\n    if (this.x.length <= newLength) {\n      this._extendStorage(newLength);\n    }\n    this.x.set(other.x.slice(0, other.length), this.length);\n    this.y.set(other.y.slice(0, other.length), this.length);\n    this.length = newLength;\n    return this;\n  }\n\n  translate(dx, dy) {\n    for (let i = 0; i < this.length; i++) {\n      this.x[i] += dx;\n      this.y[i] += dy;\n    }\n    return this;\n  }\n\n  forEach(callback, begin, end) {\n    begin = begin || 0;\n    end = end || this.length;\n    for (let i = begin; i < end; i++) {\n      const shouldStop = callback(this.x[i], this.y[i], i);\n      if (shouldStop) return;\n    }\n  }\n\n  slice(begin, end) {\n    const length = end - begin;\n    const slice = new this.constructor(length);\n    slice.x.set(this.x.slice(begin, end));\n    slice.y.set(this.y.slice(begin, end));\n    slice.length = length;\n    return slice;\n  }\n\n  filter(filterFunc) {\n    const filtered = new this.constructor();\n    this.forEach((x, y) => {\n      filtered.pushIf(x, y, filterFunc);\n    });\n    return filtered;\n  }\n}\n","import PointList from './PointList';\nimport Line from './Line';\n\nexport default class Polygon extends PointList {\n  clip(x1, y1, x2, y2, isInFunc) {\n    const line = new Line(x1, y1, x2, y2);\n\n    const result = new Polygon();\n    const maxI = this.length - 1;\n    let lastX = this.x[maxI];\n    let lastY = this.y[maxI];\n    let lastIsIn = isInFunc(lastX, lastY);\n    for (let i = 0; i <= maxI; i++) {\n      const x = this.x[i];\n      const y = this.y[i];\n      const isIn = isInFunc(x, y);\n      if (isIn ^ lastIsIn) {\n        const intersect = line.intersectWith(new Line(lastX, lastY, x, y));\n        result.push(intersect[0], intersect[1]);\n      }\n      if (isIn) result.push(x, y);\n      lastX = x;\n      lastY = y;\n      lastIsIn = isIn;\n    }\n    return result;\n  }\n\n  simplify(epsilon) {\n    const epsilon2 = epsilon * epsilon;\n    const polygon = this._douglasPeucker(epsilon2);\n\n    // remove very short lines left by douglasPeucker for some reason\n    const result = new Polygon();\n    const maxI = polygon.length - 1;\n    let curX = polygon.x[maxI];\n    let curY = polygon.y[maxI];\n    result.push(curX, curY);\n    polygon.forEach((x, y) => {\n      const line = new Line(curX, curY, x, y);\n      if (line.squareLength >= epsilon2) {\n        curX = x;\n        curY = y;\n        result.push(curX, curY);\n      }\n    });\n    return result;\n  }\n\n  _douglasPeucker(epsilon2) {\n    // https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n    if (this.length <= 3) return this;\n\n    // Find the point with the maximum distance\n    const maxI = this.length - 1;\n    let maxDistance2 = 0;\n    let maxDistanceIndex = 0;\n    const line = new Line(this.x[0], this.y[0], this.x[maxI], this.y[maxI]);\n    for (let i = 1; i < maxI; i++) {\n      const distance2 = line.squareDistanceFrom(this.x[i], this.y[i]);\n      if (distance2 > maxDistance2) {\n        maxDistance2 = distance2;\n        maxDistanceIndex = i;\n      }\n    }\n\n    // If max distance is greater than epsilon, recursively simplify\n    if (maxDistance2 <= epsilon2) {\n      const result = new Polygon(2);\n      result.push(this.x[0], this.y[0]);\n      result.push(this.x[maxI], this.y[maxI]);\n      return result;\n    }\n\n    const result = new Polygon();\n    result.concat(this.slice(0, maxDistanceIndex)._douglasPeucker(epsilon2));\n    result.concat(this.slice(maxDistanceIndex, this.length)._douglasPeucker(epsilon2));\n    return result;\n  }\n}\n","/* eslint no-restricted-globals: 0 */\nimport ComputeShapeOutside from './classes/ComputeShapeOutside';\n\nself.addEventListener('message', (e) => {\n  const { imageData, options } = e.data;\n  const result = (new ComputeShapeOutside(imageData, options)).run();\n  self.postMessage(result);\n});\n"],"sourceRoot":""}